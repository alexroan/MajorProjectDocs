\chapter{Implementation}

The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 

You can conclude this section by reviewing the end of the implementation stage against the planned requirements. 

\section{Overview}
	There were a few quite large scale changes in though during the implementation of the project. A number involved the structure of the API / database controller written in PHP. 
	
\section{PHP}
	A few languages were considered for this project, these include Ruby, Python and Perl. Perl was the first to be discarded. This was mainly due to its performance and usability when used in an Object Oriented fashion. Ruby with Ruby of Rails provides a very stable platform to develop upon, but does not quite have the flexibility that I intended to yield in the development. The final decision came between Python and PHP. Python is a clean language with very good performance and is easy to use. However, the flexibility that PHP provides when developing web pages and its good Object Oriented capabilities meant that I sided with it even though its performance may not be as good as Python.
	
	The implementation of the PHP application began based on the principle that the website files generating the HTML and JavaScript output for the interface would be completely separate from the API / database control type structure that would control all access to the database. Both would be developed in PHP and would use some form or many forms of HTTP protocol to transfer between the two. During the implementation stage, prototypes were developed which made use of HTTP Post to post JSON test data across from a mock website to an API which handled the database. Although this worked, it started to seem slightly pointless separating the two so much. If the user interface was a mobile based application, an API would need to be developed in order for the application to access the database. The website however, did not to be entirely separated from the API, and if it was it would mean that all interaction would have to be done via HTTP protocols. Instead, while the website files are located seperately from the database controller files, the website files do have access to the controller classes so that functions inside the controller classes can be called upon by the website files. 
	
\section{Google Directions API}
	Google Directions API was considered the most applicable API for generating the journey steps that were needed to store for each of the journeys. Implementing the use of this API within the application proved to be a bit of a struggle when parsing the output retrieved from the API. But once the layers of arrays were mastered, slotting the desired information into the database tables came quickly after. 
	
	The API allows for an origin, a destination and up to 8 way points parsed to it. It then returns a JSON string detailing the global positioning in latitude and longitude of the origin, destination and waypoints, and an array of route data for each of the routes calculated. The API can be set to only output a single route if necessary. The route data hold an array of every leg of the journey. The legs of the route are split by each of the way points, meaning if no way points are parsed to the API then there will only be one leg in the resulting route data. Each leg holds an array of steps. These steps describe the geographical location and html instructions of each of the main steps on the journey. It is this step data that my service must be able to retrieve and store to compile a full series of journey steps for each journey. I need this step data to perform more complex searches upon journeys.
	
	The step data stored in the 'Journey\textunderscore Step' table is used during the searching of journeys. If a user searches for a Journey between 'Brecon' and 'Cardiff', the search would not only look through the main 'Journey' table for journey with that origin and destination data, but it looks through journey step data too. So this search could find a journey from Aberystwyth to Bristol which has step data running through or near 'Brecon' and 'Cardiff'. 
	
	The problem with these journey steps comes into play with journeys involving long single-motorway journeys. The API only produces a step when a prompt is issued to the driver along the journey. At 'Brecon', the API may issue a step which issues a direction to 'Go Over the Roundabout' in the middle of the town. The API logs this as a major event, considers it as a step and logs the geographical location in the JSON. If the journey is simply a single motorway from A to B then there won't be any major events along the way, meaning the distance between steps could be tens if not hundreds of miles. I found this out when posting a journey from 'Cardiff' to 'London'. The vast majority of this journey is spent travelling on a single motorway, the M4. When testing the search function, I wanted to hitch a ride from 'Reading', which lies just off the route between 'Cardiff' and 'London', to 'London'. Unfortunately, there were no steps anywhere near 'Reading' on the journey from 'Cardiff' to 'London' because it was a straight motorway drive past 'Reading'. The previous step was located too far to the west, before the motorway, and the next step was located too far to the east, near 'London' for the location of 'Reading' to be picked up in the search.
	
	There are other limitations to using this API also. There is a maximum limit of eight way points that can be parsed through the URL. If a journey was shared by a user with a people carrier of more than four spare seats, they could have many more passenger hitch their journey. If each of the passengers has two way points, meaning that their pickup and drop off points are different to the journey origin and destination, the API will not accept the additional way point parameters. As well as this, all Google APIs have a limitation on an IP address' daily usage allowance to 2,500 requests per day. This is a high number but with a decent size user base it could very easily cap this minimum, prompting the purchase of the Business license\cite{google_api_allowance} which takes the limit up to one hundred thousand requests per day and allows 23 way points in total per request.
	
\section{Google Geocoding API}
	The Google Geocoding API\cite{google_geocoding_api} was needed for the search function I implemented to work properly. Once the journey and the journey steps had been saved to the database, the more complex search method needed to be developed. each journey step in the 'Journey\textunderscore Step table has a latitude and longitude which needed to be utilised to perform searches involving partial journeys. 
	
	If a journey from 'Aberystwyth' to 'Bristol' routed through 'Brecon' and 'Cardiff', A search for a journey between 'Brecon' and 'Cardiff' would need to return that journey. The Geocoding API was used to retrieve the geographical location in the form of latitude and longitude of the two search locations. These locations could then be used to search not only through the 'Journey' table, which stores the latitude and longitude of the origin and destination, but also through the 'Journey\textunderscore Step' table, which holds the latitudes and longitudes of journey steps of each step on each journey. This enables the search to retrieve larger journeys of partial routes.
	
\section{Database}	

The aim of the database design was to make the most simple design possible, which would still carry out the desired functions of the site. It was one of the main issues that contributed to the decision of using a traditional development methodology instead of an agile one. A full database Diagram can be found in the appendix.

The database structure and relation underwent a slight change from the original idea. Originally, as the link between 'hitch\textunderscore request' entries and 'journey' entries there was going to be a 'hitch' table, which simply stored the primary keys of both the 'hitch\textunderscore request' entry and the related 'journey' entry. Instead, the 'hitch\textunderscore request' table has an attribute called 'hr\textunderscore jr', which stores the primary key of the entry in the 'journey' table that the hitch request relates to.
	
\section{Database Controllers}
	The database controllers refer to the group of object oriented classes that control data flow to and from the database. Initially, during the prototypes and early planning, this was the API that would be access via HTTP protocols from the website files. There were many deliberations over how this API or database controller would be structured.
	
	At first there were prototypes developed which were entirely procedural. They would accept JSON via HTTP post and deal with it by decoding it and parse the data to the required specific function which would encode the result. This worked very well in early testing but began to cause a lot of problems when it came to refactoring or adding attempting to add new or edit existing features. Eventually, the development of the current form of interface came to be. In MVC terms, the Model and the Controllers are bunched together, with the website files acting as the View.

\subsection{Searching and Hitching Journeys}
As stated in the requirements, one of the most important aspects of the project was to produce a search which not only returned journeys which matched origin and destinations, but returned journeys which passed through places that were being serached. As explained in the 'Google Directions API' section of this chapter, the Google Directions API was used to store journey steps as well as journeys. This part of the functionality proved to be the most difficult to get right.

Once the serach function had been developed and was working correctly: returning journeys which not only started and ended at the searched locations, but journeys which passed through such searched locations; the hitch request was subject to acceptance or denial by the driver of the journey. If the driver acceptede the hitch and it involved only a part of the full journey, the journey steps needed to be modified in the database to include the new waypoints. The management of journey steps in the database and PHP database controller classes proved quite difficult, but was evetually accomplished by the communication between controller classes. The acceptance of hitch requests follow these steps:

\begin{itemize}
\item Move current journey steps relating to journey into 'journey\textunderscore step\textunderscore temp' table
\item Retrieve all accepted hitch requests for journey from 'hitch\textunderscore request' table
\item Use the origin, destination and waypoints from the accepted hitch requests to retrieve new route data from google directions API
\item Parse the resulting json into journey steps
\item Insert the new journey steps into the 'journey\textunderscore step' table
\item Change the reponse to the hitch request to True
\item Decrement the amount of spaces left on the journey
\item Delete the old journey steps from the 'journey\textunderscore step\textunderscore temp' table
\end{itemize}

Provided a more generous time-scale, I would have included a feature counting the spaces available during each part of the journey. For example, adding a 'js\textunderscore spaces\textunderscore available' field to the 'journey\textunderscore step' table to account for pick ups and drop off decrementing and incrementing the spaces left as the journey travels along the route.
	
\section{Website}
	Communication with the API started as a JSON interface over HTTP post. This proved to be little more than an over-separation of the two structures and over complication of the design. The development of the website did take some time, but once the foundations of the database controller classes were laid down, it was simply a case of developing the website files which would make use of them.
	
	The use of the Bootstrap CSS library really helped the development of the website. Simplicity was key and Bootstrap steered the site towards a formalised visual structure so that each page seemed to appear structurally identical to the last. It was also very easy to maintain and manage when needing to change the look of things on a page.

\section{Review}
	All of the basic requirements of the project were fulfilled in the end. However, more requirements would have been introduced had the timespan of the project been greater. This would have made the project much more usable and encourage more users to join up had they been introduced.
