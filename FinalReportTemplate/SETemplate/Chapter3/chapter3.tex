\chapter{Implementation}

The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?

It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant? 

You can conclude this section by reviewing the end of the implementation stage against the planned requirements. 

\section{Overview}
	There were a few quite large scale changes in though during the implementation of the project. A number involved the structure of the API / database controller written in PHP. 
	
\section{PHP}
	A few languages were considered for this project, these include Ruby, Python and Perl. Perl was the first to be discarded. This was mainly due to its performance and usability when used in an Object Oriented fashion. Ruby with Ruby of Rails provides a very stable platform to develop upon, but does not quite have the flexibility that I intended to yield in the development. The final decision came between Python and PHP. Python is a clean language with very good performance and is easy to use. However, the flexibility that PHP provides when developing web pages and its good Object Oriented capabilities meant that I sided with it even though its performance may not be as good as Python.
	
	The implementation of the PHP application began based on the principle that the website files generating the HTML and JavaScript output for the interface would be completely separate from the API / database control type structure that would control all access to the database. Both would be developed in PHP and would use some form or many forms of HTTP protocol to transfer between the two. During the implementation stage, prototypes were developed which made use of HTTP Post to post JSON test data across from a mock website to an API which handled the database. Although this worked, it started to seem slightly pointless separating the two so much. If the user interface was a mobile based application, an API would need to be developed in order for the application to access the database. The website however, did not to be entirely separated from the API which would mean all interaction would have to be done via HTTP protocols. Instead, while the website files are located away from the database controller files, the website files do have access to the controller classes so that functions inside the controller classes can be called upon by the website files. 
	
\section{Google Directions API}
	Google Directions API was considered the most applicable API for generating the journey steps that were needed to store for each of the journeys. Implementing the use of this API within the application proved to be a bit of a struggle when parsing the output retrieved from the API. But once the layers of arrays were mastered, slotting the desired information into the database tables came quickly after. 
	
	The API allows for an origin, a destination and up to 8 way points parsed to it. It then returns a JSON string detailing the global positioning in latitude and longitude of the origin, destination and waypoints, and an array of route data for each of the routes calculated. The API can be set to only output a single route if necessary. The route data hold an array of every leg of the journey. The legs of the route are split by each of the way points, meaning if no way points are parsed to the API then there will only be one leg in the resulting route data. Each leg holds an array of steps. These steps describe the geographical location and html instructions of each of the main steps on the journey. It is this step data that my service must be able to retrieve and store to compile a full series of journey steps for each journey. I need this step data to perform more complex searches upon journeys.
	
	The step data stored in the 'Journey\textunderscore Step' table is used during the searching of journeys. If a user searches for a Journey between 'Brecon' and 'Cardiff', the search would not only look through the main 'Journey' table for journey with that origin and destination data, but it looks through journey step data too. So this search could find a journey from Aberystwyth to Bristol which has step data running through or near 'Brecon' and 'Cardiff'. 
	
	The problem with these journey steps comes into play with journeys involving long single-motorway journeys. The API only produces a step when a prompt is issued to the driver along the journey. At 'Brecon', the API may issue a step which issues a direction to 'Go Over the Roundabout' in the middle of the town. The API logs this as a major event, considers it as a step and logs the geographical location in the JSON. If the journey is simply a single motorway from A to B then there won't be any major events along the way, meaning the distance between steps could be tens if not hundreds of miles. I found this out when posting a journey from 'Cardiff' to 'London'. The vast majority of this journey is spent travelling on a single motorway, the M4. When testing the search function, I wanted to hitch a ride from 'Reading', which lies just off the route between 'Cardiff' and 'London', to 'London'. Unfortunately, there were no steps anywhere near 'Reading' on the journey from 'Cardiff' to 'London' because it was a straight motorway drive past 'Reading'. The previous step was located too far to the west, before the motorway, and the next step was located too far to the east, near 'London' for the location of 'Reading' to be picked up in the search.
	
	There are other limitations to using this API also. There is a maximum limit of eight way points that can be parsed through the URL. If a journey was shared by a user with a people carrier of more than four spare seats, they could have many more passenger hitch their journey. If each of the passengers has two way points, meaning that their pickup and drop off points are different to the journey origin and destination, the API will not accept the additional way point parameters. As well as this, all Google APIs have a limitation on an IP address' daily usage allowance to 2,500 requests per day. This is a high number but with a decent size user base it could very easily cap this minimum, prompting the purchase of the Business license\cite{google_api_allowance} which takes the limit up to one hundred thousand requests per day and allows 23 way points in total per request.
	
\section{Google Geocoding API}
	The Google Geocoding API\cite{google_geocoding_api} was needed for the search function I implemented to work properly. Once the journey and the journey steps had been saved to the database, the more complex search method needed to be developed. each journey step in the 'Journey\textunderscore Step table has a latitude and longitude which needed to be utilised to perform searches involving partial journeys. 
	
	If a journey from 'Aberystwyth' to 'Bristol' routed through 'Brecon' and 'Cardiff', A search for a journey between 'Brecon' and 'Cardiff' would need to return that journey. The Geocoding API was used to retrieve the geographical location in the form of latitude and longitude of the two search locations. These locations could then be used to search not only through the 'Journey' table, which stores the latitude and longitude of the origin and destination, but also through the 'Journey\textunderscore Step' table, which holds the latitudes and longitudes of journey steps of each step on each journey. This enables the search to retrieve larger journeys of partial routes.
	
\section{Database}	
	
\section{Database Controllers}
	The database controllers refer to the group of object oriented classes that control data flow to and from the database. Initially, during the prototypes and early planning, this was the API that would be access via HTTP protocols from the website files. There were many deliberations over how this API or database controller would be structured.
	
	At first there were prototypes developed which were entirely procedural. They would accept JSON via HTTP post and deal with it by decoding it and parse the data to the required specific function which would encode the result. This worked very well in early testing but began to cause a lot of problems when it came to refactoring or adding attempting to add new or edit existing features.
	
	Eventually, the development of the current form of interface came to be. In MVD terms, the Model and the Controllers are bunched together, with the website files acting as the View.
	
\section{Website}
	Communication with the API started as a JSON interface over HTTP post. This proved to be little more than an over-separation of the two structures and over complication of the design. The development of the website did take some time, but once the foundations of the database controller classes were laid down, it was simply a case of developing the website files which would make use of them.
	
	The use of the Bootstrap CSS library really helped the development of the website. Simplicity was key and Bootstrap steered the site towards a formalised visual structure so that each page seemed to appear structurally identical to the last. It was also very easy to maintain and manage when needing to change the look of things on a page.
